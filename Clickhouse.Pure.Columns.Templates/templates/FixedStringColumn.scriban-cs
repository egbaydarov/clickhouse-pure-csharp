#nullable enable
using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;

namespace Clickhouse.Pure.Columns;

public partial class NativeFormatBlockReader
{
    {{~ for n in FixedStringTypes ~}}
    public FixedStringColumnReader ReadFixedStringColumn()
    {
        // Type header is like FixedString(N)
        if (_columnsRead >= _columnsCount)
        {
            throw new InvalidOperationException("No more columns available in this block.");
        }

        var name = ReadHeaderString();
        var type = ReadHeaderString();
        _columnsRead++;
        if (type.Length < 13
            || !MatchesType(type.Slice(0, 12), "FixedString("u8)
            || type[^1] != (byte)')')
        {
            throw new InvalidOperationException($"Column type mismatch. Expected FixedString for column '{Encoding.UTF8.GetString(name)}', but got '{Encoding.UTF8.GetString(type)}'.");
        }

        var digits = type.Slice(12, type.Length - 13);
        if (Utf8Parser.TryParse(
                source: digits,
                value: out int value,
                bytesConsumed: out _))
        {
            return FixedStringColumnReader.CreateAndConsume(_buffer.Span, ref _offset, (int)_rowsCount, value);
        }

        throw new InvalidOperationException($"Column type mismatch. Expected FixedString(number) for column '{Encoding.UTF8.GetString(name)}', but got '{Encoding.UTF8.GetString(type)}'.");
    }

    public ref struct FixedStringColumnReader : ISequentialColumnReader<string>
    {
        private readonly ReadOnlySpan<byte> _data;
        private int _offset;
        private readonly int _rows;
        private int _index;
        private readonly int _fixedLen;

        private FixedStringColumnReader(ReadOnlySpan<byte> data, int startOffset, int rows, int fixedLen)
        {
            _data = data;
            _offset = startOffset;
            _rows = rows;
            _fixedLen = fixedLen;
            _index = 0;
        }

        public static FixedStringColumnReader CreateAndConsume(ReadOnlySpan<byte> data, scoped ref int offset, int rows,
            int fixedLen)
        {
            var start = offset;
            var total = (long)rows * fixedLen;
            if (total < 0 || start + total > data.Length)
                throw new IndexOutOfRangeException("FixedString column out of range");
            offset = start + (int)total;
            return new FixedStringColumnReader(data, start, rows, fixedLen);
        }

        public int Length => _rows;

        public bool HasMoreRows() => _index < _rows;

        public string ReadNext()
        {
            if (_index >= _rows) throw new IndexOutOfRangeException("no more values");
            _index++;
            if (_offset + _fixedLen > _data.Length)
            {
                throw new IndexOutOfRangeException("fixed string out of range");
            }

            var slice = _data.Slice(_offset, _fixedLen);
            _offset += _fixedLen;

            // trim trailing zeros
            var end = slice.Length;
            while (end > 0 && slice[end - 1] == 0) end--;

            return Encoding.UTF8.GetString(slice.Slice(0, end));
        }
    }
    {{~ end ~}}
}

public partial class NativeFormatBlockWriter
{
    {{~ for n in FixedStringTypes ~}}
    public FixedStringColumnWriter CreateFixedStringColumnWriter(string columnName, int size)
    {
        if (size <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(size), "FixedString size must be a positive integer.");
        }

        var typeName = $"FixedString({size})";
        return FixedStringColumnWriter.Create(
            writer: this,
            columnName: columnName,
            typeName: typeName,
            rows: checked((int)_rowsCount),
            size: size);
    }

    public ref struct FixedStringColumnWriter : ISequentialColumnWriter<string, FixedStringColumnWriter>
    {
        private NativeFormatBlockWriter _writer;
        private readonly ulong _blockIndex;
        private readonly int _rows;
        private readonly int _size;
        private readonly byte[] _buffer;
        private int _index;

        private FixedStringColumnWriter(
            ulong blockIndex,
            NativeFormatBlockWriter writer,
            int rows,
            int size,
            byte[] buffer)
        {
            _blockIndex = blockIndex;
            _writer = writer;
            _rows = rows;
            _size = size;
            _buffer = buffer;
            _index = 0;
        }

        internal static FixedStringColumnWriter Create(
            NativeFormatBlockWriter writer,
            string columnName,
            string typeName,
            int rows,
            int size)
        {
            var totalSize = rows * size;
            var buffer = ArrayPool<byte>.Shared.Rent(totalSize);
            var blockIndex = writer.WriteColumnHeader(
                buffer: buffer,
                columnName: columnName,
                typeName: typeName,
                dataLength: totalSize);
            return new FixedStringColumnWriter(blockIndex, writer, rows, size, buffer);
        }

        public FixedStringColumnWriter WriteNext(string value)
        {
            if (_index >= _rows)
            {
                throw new InvalidOperationException("No more rows to write.");
            }

            var byteCount = Encoding.UTF8.GetByteCount(value);
            if (byteCount > _size)
            {
                throw new ArgumentOutOfRangeException(nameof(value), $"FixedString value exceeds size {_size}.");
            }

            var dest = _buffer.AsSpan(_index * _size, _size);
            dest.Clear();
            if (byteCount > 0)
            {
                _ = Encoding.UTF8.GetBytes(value.AsSpan(), dest.Slice(0, byteCount));
            }

            _index++;

            _writer.SetDataLength(_blockIndex, checked(_index * _size));
            return this;
        }

        public NativeFormatBlockWriter WriteAll(IEnumerable<string> values)
        {
            if (values is null) throw new ArgumentNullException(nameof(values));
            foreach (var value in values)
            {
                WriteNext(value);
            }

            return _writer;
        }
    }
    {{~ end ~}}
}
