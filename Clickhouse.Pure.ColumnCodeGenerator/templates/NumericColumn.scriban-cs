#nullable enable
using System;
using System.Buffers.Binary;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;

namespace Clickhouse.Pure.ColumnCodeGenerator;

public partial class NativeFormatBlockReader
{
    {{~ for n in NumericTypes ~}}
    public {{ n.ClickhouseType }}ColumnReader Advance{{ n.ClickhouseType }}Column()
    {
        if (_columnsRead >= _columnsCount)
        {
            throw new InvalidOperationException("No more columns available in this block.");
        }
 
        // header
        var name = ReadHeaderString();
        var type = ReadHeaderString();
        _columnsRead++;
        if (!MatchesType(type, "{{ n.ClickhouseType }}"u8))
        {
            throw new InvalidOperationException($"Column type mismatch. Expected {{ n.ClickhouseType }} for column {Encoding.UTF8.GetString(name)}, but got '{Encoding.UTF8.GetString(type)}'.");
        }

        return {{ n.ClickhouseType }}ColumnReader.CreateAndAdvance(_buffer.Span, ref _offset, (int)_rowsCount);
    }

    public ref struct {{ n.ClickhouseType }}ColumnReader : ISequentialColumnReader<{{ n.CsharpType }}>
    {
        private readonly int _rows;

        private readonly ReadOnlySpan<byte> _data;
        private int _offset;
        private int _index;

        private {{ n.ClickhouseType }}ColumnReader(
            ReadOnlySpan<byte> data,
            int startOffset,
            int rows)
        {
            _rows = rows;
            _data = data;
            _offset = startOffset;

            _index = 0;
        }

        public static {{ n.ClickhouseType }}ColumnReader CreateAndAdvance(
            ReadOnlySpan<byte> data,
            scoped ref int offset,
            int rows)
        {
            var start = offset;
            var total = (long)rows * {{ n.ValueSizeInBytes }};

            if (total < 0 || start + total > data.Length)
            {
                throw new IndexOutOfRangeException("Float64 column out of range");
            }

            // advance offset by ref
            offset = start + (int)total;

            return new {{ n.ClickhouseType }}ColumnReader(data, start, rows);
        }

        public int Length => _rows;

        public bool HasMoreRows() => _index < _rows;

        public {{ n.CsharpType }} GetCellValueAndAdvance()
        {
            if (_index >= _rows)
            {
                throw new IndexOutOfRangeException("No more values");
            }

            _index++;
            if (_offset + {{ n.ValueSizeInBytes }} > _data.Length)
            {
                throw new IndexOutOfRangeException("{{ n.ClickhouseType }} value out of range");
            }

            var v = {{ n.SpanInterpretFunction }}(_data.Slice(_offset, {{ n.ValueSizeInBytes }}));
            _offset += {{ n.ValueSizeInBytes }};
            return v;
        }
    }
    {{~ end ~}}
}

public partial class NativeFormatBlockWriter
{
    {{~ for n in NumericTypes ~}}
    public {{ n.ClickhouseType }}ColumnWriter Advance{{ n.ClickhouseType }}ColumnWriter(string columnName)
    {
        WriteColumnHeader(columnName, "{{ n.ClickhouseType }}");
        return {{ n.ClickhouseType }}ColumnWriter.Create(this, checked((int)_rowsCount));
    }

    public ref struct {{ n.ClickhouseType }}ColumnWriter : ISequentialColumnWriter<{{ n.CsharpType }}>
    {
        private NativeFormatBlockWriter _writer;
        private readonly int _startOffset;
        private readonly int _rows;
        private int _index;

        private {{ n.ClickhouseType }}ColumnWriter(
            NativeFormatBlockWriter writer,
            int rows,
            int startOffset)
        {
            _writer = writer;
            _rows = rows;
            _startOffset = startOffset;
            _index = 0;
        }

        internal static {{ n.ClickhouseType }}ColumnWriter Create(
            NativeFormatBlockWriter writer,
            int rows)
        {
            var startOffset = writer.ReserveFixedSizeColumn(rows, {{ n.ValueSizeInBytes }});
            return new {{ n.ClickhouseType }}ColumnWriter(writer, rows, startOffset);
        }

        public int Length => _rows;

        public void WriteCellValueAndAdvance({{ n.CsharpType }} value)
        {
            if (_index >= _rows)
            {
                throw new InvalidOperationException("No more rows to write.");
            }

            var destStart = _startOffset + _index * {{ n.ValueSizeInBytes }};
            var dest = _writer.GetWritableSpan(
                destStart,
                {{ n.ValueSizeInBytes }});
            {{~ if n.WriterValueStatements != null && n.WriterValueStatements.size > 0 ~}}
{{~ for stmt in n.WriterValueStatements ~}}
            {{ stmt }}
{{~ end ~}}
            {{~ end ~}}
            _index++;
        }

        public void WriteCellValuesAndAdvance(IEnumerable<{{ n.CsharpType }}> values)
        {
            if (values is null) throw new ArgumentNullException(nameof(values));
            foreach (var value in values)
            {
                WriteCellValueAndAdvance(value);
            }
        }

        public ReadOnlyMemory<byte> GetColumnData()
        {
            if (_index != _rows)
            {
                throw new InvalidOperationException("Attempted to get column data before all rows were written.");
            }

            return _writer.GetColumnSlice(_startOffset, _rows * {{ n.ValueSizeInBytes }});
        }
    }
    {{~ end ~}}
}