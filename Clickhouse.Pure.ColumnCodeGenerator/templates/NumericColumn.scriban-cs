#nullable enable
using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;

namespace Clickhouse.Pure.Columns;

public partial class NativeFormatBlockReader
{
    {{~ for n in NumericTypes ~}}
    public {{ n.ClickhouseType }}ColumnReader Read{{ n.ClickhouseType }}Column()
    {
        if (_columnsRead >= _columnsCount)
        {
            throw new InvalidOperationException("No more columns available in this block.");
        }
 
        // header
        var name = ReadHeaderString();
        var type = ReadHeaderString();
        _columnsRead++;
        if (!MatchesType(type, "{{ n.ClickhouseType }}"u8))
        {
            throw new InvalidOperationException($"Column type mismatch. Expected {{ n.ClickhouseType }} for column {Encoding.UTF8.GetString(name)}, but got '{Encoding.UTF8.GetString(type)}'.");
        }

        return {{ n.ClickhouseType }}ColumnReader.CreateAndConsume(_buffer.Span, ref _offset, (int)_rowsCount);
    }

    public ref struct {{ n.ClickhouseType }}ColumnReader : ISequentialColumnReader<{{ n.CsharpType }}>
    {
        private readonly int _rows;

        private readonly ReadOnlySpan<byte> _data;
        private int _offset;
        private int _index;

        private {{ n.ClickhouseType }}ColumnReader(
            ReadOnlySpan<byte> data,
            int startOffset,
            int rows)
        {
            _rows = rows;
            _data = data;
            _offset = startOffset;

            _index = 0;
        }

        public static {{ n.ClickhouseType }}ColumnReader CreateAndConsume(
            ReadOnlySpan<byte> data,
            scoped ref int offset,
            int rows)
        {
            var start = offset;
            var total = (long)rows * {{ n.ValueSizeInBytes }};

            if (total < 0 || start + total > data.Length)
            {
                throw new IndexOutOfRangeException("Float64 column out of range");
            }

            // advance offset by ref
            offset = start + (int)total;

            return new {{ n.ClickhouseType }}ColumnReader(data, start, rows);
        }

        public int Length => _rows;

        public bool HasMoreRows() => _index < _rows;

        public {{ n.CsharpType }} ReadNext()
        {
            if (_index >= _rows)
            {
                throw new IndexOutOfRangeException("No more values");
            }

            _index++;
            if (_offset + {{ n.ValueSizeInBytes }} > _data.Length)
            {
                throw new IndexOutOfRangeException("{{ n.ClickhouseType }} value out of range");
            }

            var v = {{ n.SpanInterpretFunction }}(_data.Slice(_offset, {{ n.ValueSizeInBytes }}));
            _offset += {{ n.ValueSizeInBytes }};
            return v;
        }
    }
    {{~ end ~}}
}

public partial class NativeFormatBlockWriter
{
    {{~ for n in NumericTypes ~}}
    public {{ n.ClickhouseType }}ColumnWriter Create{{ n.ClickhouseType }}ColumnWriter(string columnName)
    {
        WriteColumnHeader(columnName, "{{ n.ClickhouseType }}");
        return {{ n.ClickhouseType }}ColumnWriter.Create(this, checked((int)_rowsCount));
    }

    public ref struct {{ n.ClickhouseType }}ColumnWriter : ISequentialColumnWriter<{{ n.CsharpType }}, {{ n.ClickhouseType }}ColumnWriter>
    {
        private const int ValueSize = {{ n.ValueSizeInBytes }};

        private NativeFormatBlockWriter _writer;
        private readonly int _rows;
        private readonly byte[] _buffer;
        private int _index;
        private bool _segmentAdded;

        private {{ n.ClickhouseType }}ColumnWriter(
            NativeFormatBlockWriter writer,
            int rows,
            byte[] buffer)
        {
            _writer = writer;
            _rows = rows;
            _buffer = buffer;
            _index = 0;
            _segmentAdded = false;
        }

        internal static {{ n.ClickhouseType }}ColumnWriter Create(
            NativeFormatBlockWriter writer,
            int rows)
        {
            var totalSize = rows * ValueSize;
            var buffer = ArrayPool<byte>.Shared.Rent(totalSize);
            return new {{ n.ClickhouseType }}ColumnWriter(writer, rows, buffer);
        }

        public int Length => _rows;

        public {{ n.ClickhouseType }}ColumnWriter WriteNext({{ n.CsharpType }} value)
        {
            if (_index >= _rows)
            {
                throw new InvalidOperationException("No more rows to write.");
            }

            var dest = _buffer.AsSpan(_index * ValueSize, ValueSize);
            {{~ if n.WriterValueStatements != null && n.WriterValueStatements.size > 0 ~}}
{{~ for stmt in n.WriterValueStatements ~}}
            {{ stmt }}
{{~ end ~}}
            {{~ end ~}}
            _index++;

            if (_index == _rows)
            {
                EnsureSegmentAdded();
            }

            return this;
        }

        public NativeFormatBlockWriter WriteAll(IEnumerable<{{ n.CsharpType }}> values)
        {
            if (values is null) throw new ArgumentNullException(nameof(values));
            foreach (var value in values)
            {
                WriteNext(value);
            }

            if (_index == _rows)
            {
                EnsureSegmentAdded();
            }

            return _writer;
        }

        public ReadOnlyMemory<byte> GetColumnData()
        {
            if (_index != _rows)
            {
                throw new InvalidOperationException("Attempted to get column data before all rows were written.");
            }

            EnsureSegmentAdded();
            return new ReadOnlyMemory<byte>(_buffer, 0, _rows * ValueSize);
        }

        private void EnsureSegmentAdded()
        {
            if (_segmentAdded)
            {
                return;
            }

            var length = _rows * ValueSize;
            var segment = new ReadOnlyMemory<byte>(_buffer, 0, length);
            _writer.AddSegment(segment, _buffer);
            _segmentAdded = true;
        }
    }
    {{~ end ~}}
}