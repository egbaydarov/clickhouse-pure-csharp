#nullable enable
using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;

namespace Clickhouse.Pure.Columns;

public partial class NativeFormatBlockReader
{
    {{~ for n in NullableTypes ~}}
    public NullableStringColumnReader ReadNullableStringColumn()
    {
        if (_columnsRead >= _columnsCount)
        {
            throw new InvalidOperationException("No more columns available in this block.");
        }

        var name = ReadHeaderString();
        var type = ReadHeaderString();

        if (!MatchesType(type, "Nullable(String)"u8))
        {
            throw new InvalidOperationException($"Column type mismatch. Expected Nullable(String) for column '{Encoding.UTF8.GetString(name)}',  but got '{Encoding.UTF8.GetString(type)}'.");
        }
        return NullableStringColumnReader.CreateAndConsume(_buffer.Span, ref _offset, (int)_rowsCount);
    }

    public ref struct NullableStringColumnReader : ISequentialColumnReader<{{ n.CsharpType }}>
    {
        private readonly ReadOnlySpan<byte> _data;
        private int _offsetValues;
        private readonly int _rows;
        private int _index;
        private readonly ReadOnlySpan<byte> _nullsMask;

        private NullableStringColumnReader(ReadOnlySpan<byte> data, int startNullsOffset, int rows,
            ReadOnlySpan<byte> nullsMask)
        {
            _data = data;
            _offsetValues = startNullsOffset;
            _rows = rows;
            _nullsMask = nullsMask;
            _index = 0;
        }

        public int Length => _rows;

        public bool HasMoreRows() => _index < _rows;

        public static NullableStringColumnReader CreateAndConsume(ReadOnlySpan<byte> data, scoped ref int offset,
            int rows)
        {
            // Nulls mask first: one byte per row (1 = NULL, 0 = not null)
            if (offset + rows > data.Length) throw new IndexOutOfRangeException("nullable nulls out of range");
            var mask = data.Slice(offset, rows);
            var valuesStart = offset + rows;
            var local = valuesStart;

            // IMPORTANT: Values are encoded for every row regardless of null mask (nulls typically encoded as empty values).
            // Always read length and advance for each row, matching server encoding.
            for (var i = 0; i < rows; i++)
            {
                var len = (int)ReadUVarInt(ref local, data);
                local += len;
                if (local > data.Length)
                    throw new IndexOutOfRangeException("nullable string values out of range while scanning");
            }

            offset = local;
            return new NullableStringColumnReader(data, valuesStart, rows, mask);
        }

        public string? ReadNext()
        {
            if (_index >= _rows) throw new IndexOutOfRangeException("no more values");
            var isNull = _nullsMask[_index] != 0;
            _index++;
            var len = (int)ReadUVarInt(ref _offsetValues, _data);
            if (_offsetValues + len > _data.Length)
                throw new IndexOutOfRangeException("nullable string value out of range");
            if (isNull)
            {
                _offsetValues += len;
                return null;
            }

            var valueSpan = _data.Slice(_offsetValues, len); 
            _offsetValues += len;
            return Encoding.UTF8.GetString(valueSpan);
        }
    }
    {{~ end ~}}
}

public partial class NativeFormatBlockWriter
{
    {{~ for n in NullableTypes ~}}
    public NullableStringColumnWriter CreateNullableStringColumnWriter(string columnName)
    {
        return NullableStringColumnWriter.Create(
            writer: this,
            columnName: columnName,
            rows: checked((int)_rowsCount));
    }

    public ref struct NullableStringColumnWriter : ISequentialColumnWriter<{{ n.CsharpType }}, NullableStringColumnWriter>
    {
        private const int InitialCapacity = 1024;

        private NativeFormatBlockWriter _writer;
        private readonly ulong _blockIndex;
        private readonly int _rows;
        private readonly int _maskLength;
        private byte[] _buffer;
        private int _offset;
        private int _index;

        private NullableStringColumnWriter(
            ulong blockIndex,
            NativeFormatBlockWriter writer,
            int rows,
            byte[] buffer)
        {
            _blockIndex = blockIndex;
            _writer = writer;
            _rows = rows;
            _maskLength = rows;
            _buffer = buffer;
            _offset = rows;
            _index = 0;
            _buffer.AsSpan(0, _maskLength).Clear();
            _writer.SetDataLength(_blockIndex, _offset);
        }

        internal static NullableStringColumnWriter Create(
            NativeFormatBlockWriter writer,
            string columnName,
            int rows)
        {
            var initial = Math.Max(rows + 64, InitialCapacity);
            var buffer = ArrayPool<byte>.Shared.Rent(initial);
            var blockIndex = writer.WriteColumnHeader(
                buffer: buffer,
                columnName: columnName,
                typeName: "Nullable(String)",
                dataLength: 0);
            return new NullableStringColumnWriter(blockIndex, writer, rows, buffer);
        }

        public NullableStringColumnWriter WriteNext({{ n.CsharpType }} value)
        {
            if (_index >= _rows)
            {
                throw new InvalidOperationException("No more rows to write.");
            }

            var maskSpan = _buffer.AsSpan(0, _maskLength);
            if (value is null)
            {
                maskSpan[_index] = 1;
                _buffer = _writer.EnsureCapacity(
                    index: _blockIndex,
                    offset: _offset,
                    required: _offset + NativeFormatBlockWriter.MaxVarintLen64);
                _offset += NativeFormatBlockWriter.WriteUVarInt(_buffer.AsSpan(_offset), 0);
            }
            else
            {
                maskSpan[_index] = 0;
                var byteCount = Encoding.UTF8.GetByteCount(value);
                _buffer = _writer.EnsureCapacity(
                    index: _blockIndex,
                    offset: _offset,
                    required: _offset + NativeFormatBlockWriter.MaxVarintLen64 + byteCount);
                _offset += NativeFormatBlockWriter.WriteUtf8StringValue(_buffer.AsSpan(_offset), value);
            }

            _index++;
            _writer.SetDataLength(_blockIndex, _offset);

            return this;
        }

        public NativeFormatBlockWriter WriteAll(IEnumerable<{{ n.CsharpType }}> values)
        {
            if (values is null) throw new ArgumentNullException(nameof(values));
            foreach (var value in values)
            {
                WriteNext(value);
            }

            return _writer;
        }
    }
    {{~ end ~}}
}