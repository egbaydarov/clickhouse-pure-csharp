#nullable enable
using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;

namespace Clickhouse.Pure.Columns;

public partial class NativeFormatBlockReader
{
    {{~ for n in NullableTypes ~}}
    public NullableStringColumnReader ReadNullableStringColumn()
    {
        if (_columnsRead >= _columnsCount)
        {
            throw new InvalidOperationException("No more columns available in this block.");
        }

        var name = ReadHeaderString();
        var type = ReadHeaderString();

        if (!MatchesType(type, "Nullable(String)"u8))
        {
            throw new InvalidOperationException($"Column type mismatch. Expected Nullable(String) for column '{Encoding.UTF8.GetString(name)}',  but got '{Encoding.UTF8.GetString(type)}'.");
        }
        return NullableStringColumnReader.CreateAndConsume(_buffer.Span, ref _offset, (int)_rowsCount);
    }

    public ref struct NullableStringColumnReader : ISequentialColumnReader<{{ n.CsharpType }}>
    {
        private readonly ReadOnlySpan<byte> _data;
        private int _offsetValues;
        private readonly int _rows;
        private int _index;
        private readonly ReadOnlySpan<byte> _nullsMask;

        private NullableStringColumnReader(ReadOnlySpan<byte> data, int startNullsOffset, int rows,
            ReadOnlySpan<byte> nullsMask)
        {
            _data = data;
            _offsetValues = startNullsOffset;
            _rows = rows;
            _nullsMask = nullsMask;
            _index = 0;
        }

        public int Length => _rows;

        public bool HasMoreRows() => _index < _rows;

        public static NullableStringColumnReader CreateAndConsume(ReadOnlySpan<byte> data, scoped ref int offset,
            int rows)
        {
            // Nulls mask first: one byte per row (1 = NULL, 0 = not null)
            if (offset + rows > data.Length) throw new IndexOutOfRangeException("nullable nulls out of range");
            var mask = data.Slice(offset, rows);
            var valuesStart = offset + rows;
            var local = valuesStart;

            // IMPORTANT: Values are encoded for every row regardless of null mask (nulls typically encoded as empty values).
            // Always read length and advance for each row, matching server encoding.
            for (var i = 0; i < rows; i++)
            {
                var len = (int)ReadUVarInt(ref local, data);
                local += len;
                if (local > data.Length)
                    throw new IndexOutOfRangeException("nullable string values out of range while scanning");
            }

            offset = local;
            return new NullableStringColumnReader(data, valuesStart, rows, mask);
        }

        public string? ReadNext()
        {
            if (_index >= _rows) throw new IndexOutOfRangeException("no more values");
            var isNull = _nullsMask[_index] != 0;
            _index++;
            var len = (int)ReadUVarInt(ref _offsetValues, _data);
            if (_offsetValues + len > _data.Length)
                throw new IndexOutOfRangeException("nullable string value out of range");
            if (isNull)
            {
                _offsetValues += len;
                return null;
            }

            var valueSpan = _data.Slice(_offsetValues, len); 
            _offsetValues += len;
            return Encoding.UTF8.GetString(valueSpan);
        }
    }
    {{~ end ~}}
}

public partial class NativeFormatBlockWriter
{
    {{~ for n in NullableTypes ~}}
    public NullableStringColumnWriter CreateNullableStringColumnWriter(string columnName)
    {
        WriteColumnHeader(columnName, "Nullable(String)");
        return NullableStringColumnWriter.Create(this, checked((int)_rowsCount));
    }

    public ref struct NullableStringColumnWriter : ISequentialColumnWriter<{{ n.CsharpType }}, NullableStringColumnWriter>
    {
        private const int InitialCapacity = 1024;

        private NativeFormatBlockWriter _writer;
        private readonly int _rows;
        private readonly int _maskLength;
        private byte[] _buffer;
        private int _offset;
        private int _index;
        private bool _segmentAdded;

        private NullableStringColumnWriter(
            NativeFormatBlockWriter writer,
            int rows,
            byte[] buffer)
        {
            _writer = writer;
            _rows = rows;
            _maskLength = rows;
            _buffer = buffer;
            _offset = rows;
            _index = 0;
            _segmentAdded = false;
            _buffer.AsSpan(0, _maskLength).Clear();
        }

        internal static NullableStringColumnWriter Create(
            NativeFormatBlockWriter writer,
            int rows)
        {
            var initial = Math.Max(rows + 64, InitialCapacity);
            var buffer = ArrayPool<byte>.Shared.Rent(initial);
            return new NullableStringColumnWriter(writer, rows, buffer);
        }

        public int Length => _rows;

        public NullableStringColumnWriter WriteNext({{ n.CsharpType }} value)
        {
            if (_index >= _rows)
            {
                throw new InvalidOperationException("No more rows to write.");
            }

            var maskSpan = _buffer.AsSpan(0, _maskLength);
            if (value is null)
            {
                maskSpan[_index] = 1;
                EnsureCapacity(_offset + NativeFormatBlockWriter.MaxVarintLen64);
                _offset += NativeFormatBlockWriter.WriteUVarInt(_buffer.AsSpan(_offset), 0);
            }
            else
            {
                maskSpan[_index] = 0;
                var byteCount = Encoding.UTF8.GetByteCount(value);
                EnsureCapacity(_offset + NativeFormatBlockWriter.MaxVarintLen64 + byteCount);
                _offset += NativeFormatBlockWriter.WriteUtf8StringValue(_buffer.AsSpan(_offset), value);
            }

            _index++;
            if (_index == _rows)
            {
                EnsureSegmentAdded();
            }

            return this;
        }

        public NativeFormatBlockWriter WriteAll(IEnumerable<{{ n.CsharpType }}> values)
        {
            if (values is null) throw new ArgumentNullException(nameof(values));
            foreach (var value in values)
            {
                WriteNext(value);
            }

            if (_index == _rows)
            {
                EnsureSegmentAdded();
            }

            return _writer;
        }

        public ReadOnlyMemory<byte> GetColumnData()
        {
            if (_index != _rows)
            {
                throw new InvalidOperationException("Attempted to get column data before all rows were written.");
            }

            EnsureSegmentAdded();
            return new ReadOnlyMemory<byte>(_buffer, 0, _offset);
        }

        private void EnsureCapacity(int required)
        {
            if (required <= _buffer.Length)
            {
                return;
            }

            var newSize = Math.Max(_buffer.Length * 2, required);
            var newBuffer = ArrayPool<byte>.Shared.Rent(newSize);
            _buffer.AsSpan(0, _offset).CopyTo(newBuffer);
            ArrayPool<byte>.Shared.Return(_buffer);
            _buffer = newBuffer;
        }

        private void EnsureSegmentAdded()
        {
            if (_segmentAdded)
            {
                return;
            }

            var segment = new ReadOnlyMemory<byte>(_buffer, 0, _offset);
            _writer.AddSegment(segment, _buffer);
            _segmentAdded = true;
        }
    }
    {{~ end ~}}
}