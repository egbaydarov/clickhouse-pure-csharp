using System;using System.Globalization;using System.Linq;using System.Security;using System.Text;using System.Threading.Tasks;namespace Clickhouse.Pure.Grpc;internal static class Program{    private static readonly int[] FixedLens = [1, 4, 8, 16, 32];    private static readonly int[] DtScales = [.. Enumerable.Range(0, 10)];    private static readonly Random Rnd = new();    private const int RowCount = 200;    private sealed class ExpectedRow    {        public string S = "";        public string[] Fs = [];        public string LcSmall = "";        public string LcLarge = "";        public uint U32;        public ushort U16;        public bool B;        public bool NsIsNull;        public string? NsValue;        public DateTimeOffset[] Dt64 = new DateTimeOffset[10];        public sbyte I8;        public short I16;        public int I32;        public long I64;        public Int128 I128;        public float F32;        public double F64;    }    static SecureString ToSecureString(string value)    {        var s = new SecureString();        foreach (var c in value) s.AppendChar(c);        s.MakeReadOnly();        return s;    }    private static async Task Main()    {        var username = "default";        var password = "default";        using var router = ClickhouseGrpcConnectionFactory.Create(            endpoint: "http://localhost:9100",            username: username,            password: password,            port: 9100);        var handler = new DefaultCallHandler(            router: router,            password: ToSecureString(username),            username: ToSecureString(password));        var version = await handler.QueryRawString("SELECT version()");        Console.Write("ClickHouse version: " + version.Item1);        const string db = "grpc_native_test";        const string table = $"{db}.some_table";        Console.WriteLine(await handler.QueryRawString($"CREATE DATABASE IF NOT EXISTS {db}"));        Console.WriteLine(await handler.QueryRawString($"DROP TABLE IF EXISTS {table};"));        Console.WriteLine(await handler.QueryRawString("INSERT INTO datetimes (some_dt64_0, some_dt64_1,some_dt64_2,some_dt64_3, some_dt64_4, some_dt64_5, some_dt64_6, some_dt64_7, some_dt64_8, some_dt64_9) FORMAT TSV\n" +                                                        "99\t9900.2\t9933.22\t33.333\t9934.4444\t9933.55555\t9933.666666\t9933.7777777\t9933.88888888\t9933.99999\n"));        var ddl = $"""                       CREATE TABLE {table}                       (                               id          UInt32,                               s           String,                               {string.Join(Environment.NewLine, FixedLens.Select(n =>                                    $"fs{n}       FixedString({n}),"))}                               lc_small    LowCardinality(String),                               lc_large    LowCardinality(String),                               u32         UInt32,                               u16         UInt16,                               b           Bool,                               {string.Join(Environment.NewLine, DtScales.Select(sc =>                                   $"dt64_s{sc}  DateTime64({sc}, 'UTC'),"))}                               i8          Int8,                               i16         Int16,                               i32         Int32,                               i64         Int64,                               i128        Int128,                               f32         Float32,                               f64         Float64,                               ns          Nullable(String)                       )                       ENGINE MergeTree                       ORDER BY id                   """;        await handler.QueryRawString(ddl);        var expected = new ExpectedRow[RowCount];        var insert = await handler.InputBulk(            initialQuery: $"INSERT INTO {table} FORMAT TabSeparated",            delimiter: "\n");        var sbRow = new StringBuilder(256);        for (var i = 0; i < RowCount; i++)        {            var e = new ExpectedRow            {                S = "s_" + RandomToken(Rnd, 6),                Fs = [.. FixedLens.Select(n => FixedLenToken(Rnd, n))],                LcSmall = GetLcSmall(Rnd),                LcLarge = GetLcLarge(Rnd),                U32 = RandUInt32(Rnd),                U16 = RandUInt16(Rnd),                B = Rnd.Next(2) == 1,                NsIsNull = Rnd.Next(10) == 0,                I8 = (sbyte)Rnd.Next(sbyte.MinValue, sbyte.MaxValue + 1),                I16 = (short)Rnd.Next(short.MinValue, short.MaxValue + 1),                I32 = Rnd.Next(),                I64 = Rnd.NextInt64(),                I128 = Rnd.NextInt64(),                F32 = (float)(Rnd.NextDouble() * 2000.0 - 1000.0),                F64 = (Rnd.NextDouble() * 1_000_000.0) - 500_000.0,            };            e.NsValue = e.NsIsNull ? null : "ns_" + RandomToken(Rnd, 5);            var dt = RandomDateTimeOffset(Rnd);            foreach (var sc in DtScales)                e.Dt64[sc] = TruncateToScale(dt, sc);            expected[i] = e;            sbRow.Clear();            sbRow.Append(i).Append('\t');            sbRow.Append(e.S).Append('\t');            foreach (var fs in e.Fs) sbRow.Append(fs).Append('\t');            sbRow.Append(e.LcSmall).Append('\t')                 .Append(e.LcLarge).Append('\t')                 .Append(e.U32.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.U16.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.B ? "1" : "0").Append('\t');            var (secs, frac) = SplitUnixParts(dt);            foreach (var sc in DtScales)                sbRow.Append(DateTime64Text(1234, frac, sc)).Append('\t');            sbRow.Append(e.I8.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.I16.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.I32.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.I64.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.I128.ToString()).Append('\t')                 .Append(e.F32.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.F64.ToString(CultureInfo.InvariantCulture)).Append('\t')                 .Append(e.NsIsNull ? @"\N" : e.NsValue);            var line = sbRow.ToString();            var isLast = (i == RowCount - 1);            await insert.WriteRowsBulkAsync(Encoding.UTF8.GetBytes(line), !isLast);        }        Console.WriteLine("Insert commit: " + await insert.Commit());        var mismatches = 0;        var rh = await handler.QueryNativeBulk($"SELECT * FROM {table} ORDER BY id");        while (true)        {            var part = await rh.ReadNext();            if (part.IsFailed()) { Console.WriteLine(part.Exception); break; }            if (part.IsMetadataResponse()) { Console.WriteLine("Meta: " + part.ResponseResult); }            if (part.IsBlock())            {                var br = part.BlockReader;                var idCol = br.AdvanceUInt32Column();                var sCol  = br.AdvanceStringColumn();                var fs1Col  = br.AdvanceFixedStringColumn();                var fs4Col  = br.AdvanceFixedStringColumn();                var fs8Col  = br.AdvanceFixedStringColumn();                var fs16Col = br.AdvanceFixedStringColumn();                var fs32Col = br.AdvanceFixedStringColumn();                var lcSmallCol = br.AdvanceLowCardinalityStringColumn();                var lcLargeCol = br.AdvanceLowCardinalityStringColumn();                var u32Col = br.AdvanceUInt32Column();                var u16Col = br.AdvanceUInt16Column();                var bCol   = br.AdvanceBoolColumn();                var dt64S0Col = br.AdvanceDateTime64Column(0, "UTC");                var dt64S1Col = br.AdvanceDateTime64Column(1, "UTC");                var dt64S2Col = br.AdvanceDateTime64Column(2, "UTC");                var dt64S3Col = br.AdvanceDateTime64Column(3, "UTC");                var dt64S4Col = br.AdvanceDateTime64Column(4, "UTC");                var dt64S5Col = br.AdvanceDateTime64Column(5, "UTC");                var dt64S6Col = br.AdvanceDateTime64Column(6, "UTC");                var dt64S7Col = br.AdvanceDateTime64Column(7, "UTC");                var dt64S8Col = br.AdvanceDateTime64Column(8, "UTC");                var dt64S9Col = br.AdvanceDateTime64Column(9, "UTC");                var i8Col = br.AdvanceInt8Column();                var i16Col = br.AdvanceInt16Column();                var i32Col = br.AdvanceInt32Column();                var i64Col = br.AdvanceInt64Column();                var i128Col = br.AdvanceInt128Column();                var f32Col = br.AdvanceFloat32Column();                var f64Col = br.AdvanceFloat64Column();                var nsCol = br.AdvanceNullableStringColumn();                while (idCol.HasMoreRows())                {                    var id = idCol.GetCellValueAndAdvance();                    var e = expected[id];                    var gotS = sCol.GetCellValueAndAdvance();                    if (gotS != e.S) Fail(ref mismatches, id, "s");                    if (fs1Col.GetCellValueAndAdvance()  != e.Fs[0]) Fail(ref mismatches, id, "fs1");                    if (fs4Col.GetCellValueAndAdvance()  != e.Fs[1]) Fail(ref mismatches, id, "fs4");                    if (fs8Col.GetCellValueAndAdvance()  != e.Fs[2]) Fail(ref mismatches, id, "fs8");                    if (fs16Col.GetCellValueAndAdvance() != e.Fs[3]) Fail(ref mismatches, id, "fs16");                    if (fs32Col.GetCellValueAndAdvance() != e.Fs[4]) Fail(ref mismatches, id, "fs32");                    if (lcSmallCol.GetCellValueAndAdvance() != e.LcSmall) Fail(ref mismatches, id, "lc_small");                    if (lcLargeCol.GetCellValueAndAdvance() != e.LcLarge) Fail(ref mismatches, id, "lc_large");                    if (u32Col.GetCellValueAndAdvance() != e.U32) Fail(ref mismatches, id, "u32");                    if (u16Col.GetCellValueAndAdvance() != e.U16) Fail(ref mismatches, id, "u16");                    if (bCol.GetCellValueAndAdvance()   != e.B)   Fail(ref mismatches, id, "b");                    if (dt64S0Col.GetCellValueAndAdvance() != e.Dt64[0]) Fail(ref mismatches, id, "dt64_s0");                    if (dt64S1Col.GetCellValueAndAdvance() != e.Dt64[1]) Fail(ref mismatches, id, "dt64_s1");                    if (dt64S2Col.GetCellValueAndAdvance() != e.Dt64[2]) Fail(ref mismatches, id, "dt64_s2");                    if (dt64S3Col.GetCellValueAndAdvance() != e.Dt64[3]) Fail(ref mismatches, id, "dt64_s3");                    if (dt64S4Col.GetCellValueAndAdvance() != e.Dt64[4]) Fail(ref mismatches, id, "dt64_s4");                    if (dt64S5Col.GetCellValueAndAdvance() != e.Dt64[5]) Fail(ref mismatches, id, "dt64_s5");                    if (dt64S6Col.GetCellValueAndAdvance() != e.Dt64[6]) Fail(ref mismatches, id, "dt64_s6");                    if (dt64S7Col.GetCellValueAndAdvance() != e.Dt64[7]) Fail(ref mismatches, id, "dt64_s7");                    if (dt64S8Col.GetCellValueAndAdvance() != e.Dt64[8]) Fail(ref mismatches, id, "dt64_s8");                    if (dt64S9Col.GetCellValueAndAdvance() != e.Dt64[9]) Fail(ref mismatches, id, "dt64_s9");                    if (i8Col.GetCellValueAndAdvance()   != e.I8)  Fail(ref mismatches, id, "i8");                    if (i16Col.GetCellValueAndAdvance()  != e.I16) Fail(ref mismatches, id, "i16");                    if (i32Col.GetCellValueAndAdvance()  != e.I32) Fail(ref mismatches, id, "i32");                    if (i64Col.GetCellValueAndAdvance()  != e.I64) Fail(ref mismatches, id, "i64");                    if (i128Col.GetCellValueAndAdvance() != e.I128) Fail(ref mismatches, id, "i128");                    if (Math.Abs(f32Col.GetCellValueAndAdvance() - e.F32) > 1e-3f) Fail(ref mismatches, id, "f32");                    if (Math.Abs(f64Col.GetCellValueAndAdvance() - e.F64) > 1e-9) Fail(ref mismatches, id, "f64");                    if (nsCol.GetCellValueAndAdvance() != e.NsValue) Fail(ref mismatches, id, "ns");                }            }            if (part.Completed) break;        }        Console.WriteLine(mismatches == 0 ? "✅ Round-trip OK" : $"❌ Mismatches: {mismatches}");    }    private static void Fail(ref int mismatches, uint id, string col)    {        mismatches++;        if (mismatches <= 20)            Console.WriteLine($"Mismatch id={id} col={col}");    }    private static DateTimeOffset RandomDateTimeOffset(Random r)    {        var min = new DateTimeOffset(1911, 1, 1, 0, 0, 0, TimeSpan.Zero);        var max = new DateTimeOffset(2065, 12, 31, 23, 59, 59, TimeSpan.Zero);        var spanSeconds = (max - min).TotalSeconds;        var seconds = (long)(r.NextDouble() * spanSeconds);        var nanos = r.Next(0, 1_000_000_000);        var ticks = nanos / 100; // truncate to 100ns ticks        return min.AddSeconds(seconds).AddTicks(ticks);    }    private static (long seconds, int fracNano9) SplitUnixParts(DateTimeOffset dt)    {        var seconds = (dt - DateTimeOffset.UnixEpoch).Ticks / TimeSpan.TicksPerSecond;        var remTicks = (dt - DateTimeOffset.UnixEpoch).Ticks % TimeSpan.TicksPerSecond;        if (remTicks < 0)        {            seconds -= 1;            remTicks += TimeSpan.TicksPerSecond;        }        var nanos = (int)(remTicks * 100);        return (seconds, nanos);    }    private static DateTimeOffset TruncateToScale(DateTimeOffset dt, int scale)    {        if (scale <= 0) return DateTimeOffset.FromUnixTimeSeconds(dt.ToUnixTimeSeconds());        if (scale >= 7) return dt.ToOffset(TimeSpan.Zero);        var pow = Pow10(7 - scale);        var sinceEpochTicks = dt.ToUniversalTime().Ticks - DateTimeOffset.UnixEpoch.Ticks;        var seconds = Math.DivRem(sinceEpochTicks, TimeSpan.TicksPerSecond, out var rem);        var truncated = rem / pow * pow;        var total = checked(seconds * TimeSpan.TicksPerSecond + truncated);        return new DateTimeOffset(DateTimeOffset.UnixEpoch.Ticks + total, TimeSpan.Zero);    }    private static long Pow10(int p)    {        long v = 1;        for (var i = 0; i < p; i++) v *= 10;        return v;    }    private static ushort RandUInt16(Random r) => (ushort)r.Next(0, 65536);    private static uint RandUInt32(Random r)    {        return unchecked((uint)r.NextInt64());    }    private static string GetLcLarge(Random r) => "L" + r.Next(0, 200).ToString("D3", CultureInfo.InvariantCulture);    private static string GetLcSmall(Random r) => r.Next(3) switch { 0 => "A", 1 => "B", _ => "C" };    private static string FixedLenToken(Random r, int n)    {        var tok = RandomToken(r, Math.Min(n, 16));        if (tok.Length > n) tok = tok[..n];        if (tok.Length < n) tok = tok.PadRight(n, '_');        return tok;    }    private static string DateTime64Text(long unixSeconds, int fracNano9, int scale)    {        if (scale == 0)        {            return $"{unixSeconds.ToString(CultureInfo.InvariantCulture)}.0";        }                var negative = unixSeconds < 0;        long secOut = unixSeconds;        int fracOut = fracNano9;        if (negative && fracOut > 0)        {            secOut += 1;            fracOut = 1_000_000_000 - fracOut;        }        var fracText9 = fracOut.ToString("D9", CultureInfo.InvariantCulture);        var fracTrunc = fracText9.Substring(0, scale);        if (negative)            return "-" + Math.Abs(secOut).ToString(CultureInfo.InvariantCulture) + "." + fracTrunc;        return secOut.ToString(CultureInfo.InvariantCulture) + "." + fracTrunc;    }    private static string RandomToken(Random r, int len)    {        const string alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ0123456789";        var sb = new StringBuilder(len);        for (var i = 0; i < len; i++) sb.Append(alphabet[r.Next(alphabet.Length)]);        return sb.ToString();    }}